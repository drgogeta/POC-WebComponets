{"version":3,"file":"static/js/66.b71707b1.chunk.js","mappings":"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","sources":["../../app-1/dist/esm/active-router-d073ec9d.js","../../app-1/dist/esm/dom-utils-109a7d75.js","../../app-1/dist/esm/location-utils-312665d3.js","../node_modules/@babel/runtime/helpers/esm/toArray.js","../../app-1/dist/esm/match-path-4b5c7d98.js","../../app-1/dist/esm/stencil-route-link.entry.js","../node_modules/@babel/runtime/helpers/esm/defineProperty.js"],"sourcesContent":["import { h } from './index-83665fc4.js';\n\nconst createProviderConsumer = (defaultState, consumerRender) => {\r\n    let listeners = new Map();\r\n    let currentState = defaultState;\r\n    const updateListener = (fields, instance) => {\r\n        if (Array.isArray(fields)) {\r\n            [...fields].forEach(fieldName => {\r\n                instance[fieldName] = currentState[fieldName];\r\n            });\r\n        }\r\n        else {\r\n            instance[fields] = Object.assign({}, currentState);\r\n        }\r\n    };\r\n    const subscribe = (instance, propList) => {\r\n        if (!listeners.has(instance)) {\r\n            listeners.set(instance, propList);\r\n            updateListener(propList, instance);\r\n        }\r\n        return () => {\r\n            if (listeners.has(instance)) {\r\n                listeners.delete(instance);\r\n            }\r\n        };\r\n    };\r\n    const Provider = ({ state }, children) => {\r\n        currentState = state;\r\n        listeners.forEach(updateListener);\r\n        return children;\r\n    };\r\n    const Consumer = (props, children) => {\r\n        // The casting on subscribe is to allow for crossover through the stencil compiler\r\n        // In the future we should allow for generics in components.\r\n        return consumerRender(subscribe, children[0]);\r\n    };\r\n    const injectProps = (Cstr, fieldList) => {\r\n        const CstrPrototype = Cstr.prototype;\r\n        const cstrConnectedCallback = CstrPrototype.connectedCallback;\r\n        const cstrDisconnectedCallback = CstrPrototype.disconnectedCallback;\r\n        CstrPrototype.connectedCallback = function () {\r\n            subscribe(this, fieldList);\r\n            if (cstrConnectedCallback) {\r\n                return cstrConnectedCallback.call(this);\r\n            }\r\n        };\r\n        CstrPrototype.disconnectedCallback = function () {\r\n            listeners.delete(this);\r\n            if (cstrDisconnectedCallback) {\r\n                cstrDisconnectedCallback.call(this);\r\n            }\r\n        };\r\n    };\r\n    return {\r\n        Provider,\r\n        Consumer,\r\n        injectProps\r\n    };\r\n};\n\nconst ActiveRouter = createProviderConsumer({\r\n    historyType: 'browser',\r\n    location: {\r\n        pathname: '',\r\n        query: {},\r\n        key: ''\r\n    },\r\n    titleSuffix: '',\r\n    root: '/',\r\n    routeViewsUpdated: () => { }\r\n}, (subscribe, child) => (h(\"context-consumer\", { subscribe: subscribe, renderer: child })));\n\nexport { ActiveRouter as A };\n","const getConfirmation = (win, message, callback) => (callback(win.confirm(message)));\r\nconst isModifiedEvent = (ev) => (ev.metaKey || ev.altKey || ev.ctrlKey || ev.shiftKey);\r\n/**\r\n * Returns true if the HTML5 history API is supported. Taken from Modernizr.\r\n *\r\n * https://github.com/Modernizr/Modernizr/blob/master/LICENSE\r\n * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js\r\n * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586\r\n */\r\nconst supportsHistory = (win) => {\r\n    const ua = win.navigator.userAgent;\r\n    if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&\r\n        ua.indexOf('Mobile Safari') !== -1 &&\r\n        ua.indexOf('Chrome') === -1 &&\r\n        ua.indexOf('Windows Phone') === -1) {\r\n        return false;\r\n    }\r\n    return win.history && 'pushState' in win.history;\r\n};\r\n/**\r\n * Returns true if browser fires popstate on hash change.\r\n * IE10 and IE11 do not.\r\n */\r\nconst supportsPopStateOnHashChange = (nav) => (nav.userAgent.indexOf('Trident') === -1);\r\n/**\r\n * Returns false if using go(n) with hash history causes a full page reload.\r\n */\r\nconst supportsGoWithoutReloadUsingHash = (nav) => (nav.userAgent.indexOf('Firefox') === -1);\r\nconst isExtraneousPopstateEvent = (nav, event) => (event.state === undefined &&\r\n    nav.userAgent.indexOf('CriOS') === -1);\r\nconst storageAvailable = (win, type) => {\r\n    const storage = win[type];\r\n    const x = '__storage_test__';\r\n    try {\r\n        storage.setItem(x, x);\r\n        storage.removeItem(x);\r\n        return true;\r\n    }\r\n    catch (e) {\r\n        return e instanceof DOMException && (\r\n        // everything except Firefox\r\n        e.code === 22 ||\r\n            // Firefox\r\n            e.code === 1014 ||\r\n            // test name field too, because code might not be present\r\n            // everything except Firefox\r\n            e.name === 'QuotaExceededError' ||\r\n            // Firefox\r\n            e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&\r\n            // acknowledge QuotaExceededError only if there's something already stored\r\n            storage.length !== 0;\r\n    }\r\n};\n\nexport { supportsHistory as a, supportsPopStateOnHashChange as b, isExtraneousPopstateEvent as c, supportsGoWithoutReloadUsingHash as d, getConfirmation as g, isModifiedEvent as i, storageAvailable as s };\n","const hasBasename = (path, prefix) => {\r\n    return (new RegExp('^' + prefix + '(\\\\/|\\\\?|#|$)', 'i')).test(path);\r\n};\r\nconst stripBasename = (path, prefix) => {\r\n    return hasBasename(path, prefix) ? path.substr(prefix.length) : path;\r\n};\r\nconst stripTrailingSlash = (path) => {\r\n    return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;\r\n};\r\nconst addLeadingSlash = (path) => {\r\n    return path.charAt(0) === '/' ? path : '/' + path;\r\n};\r\nconst stripLeadingSlash = (path) => {\r\n    return path.charAt(0) === '/' ? path.substr(1) : path;\r\n};\r\nconst parsePath = (path) => {\r\n    let pathname = path || '/';\r\n    let search = '';\r\n    let hash = '';\r\n    const hashIndex = pathname.indexOf('#');\r\n    if (hashIndex !== -1) {\r\n        hash = pathname.substr(hashIndex);\r\n        pathname = pathname.substr(0, hashIndex);\r\n    }\r\n    const searchIndex = pathname.indexOf('?');\r\n    if (searchIndex !== -1) {\r\n        search = pathname.substr(searchIndex);\r\n        pathname = pathname.substr(0, searchIndex);\r\n    }\r\n    return {\r\n        pathname,\r\n        search: search === '?' ? '' : search,\r\n        hash: hash === '#' ? '' : hash,\r\n        query: {},\r\n        key: ''\r\n    };\r\n};\r\nconst createPath = (location) => {\r\n    const { pathname, search, hash } = location;\r\n    let path = pathname || '/';\r\n    if (search && search !== '?') {\r\n        path += (search.charAt(0) === '?' ? search : `?${search}`);\r\n    }\r\n    if (hash && hash !== '#') {\r\n        path += (hash.charAt(0) === '#' ? hash : `#${hash}`);\r\n    }\r\n    return path;\r\n};\r\nconst parseQueryString = (query) => {\r\n    if (!query) {\r\n        return {};\r\n    }\r\n    return (/^[?#]/.test(query) ? query.slice(1) : query)\r\n        .split('&')\r\n        .reduce((params, param) => {\r\n        let [key, value] = param.split('=');\r\n        params[key] = value ? decodeURIComponent(value.replace(/\\+/g, ' ')) : '';\r\n        return params;\r\n    }, {});\r\n};\n\nconst isAbsolute = (pathname) => {\r\n    return pathname.charAt(0) === '/';\r\n};\r\nconst createKey = (keyLength) => {\r\n    return Math.random().toString(36).substr(2, keyLength);\r\n};\r\n// About 1.5x faster than the two-arg version of Array#splice()\r\nconst spliceOne = (list, index) => {\r\n    for (let i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {\r\n        list[i] = list[k];\r\n    }\r\n    list.pop();\r\n};\r\n// This implementation is based heavily on node's url.parse\r\nconst resolvePathname = (to, from = '') => {\r\n    let fromParts = from && from.split('/') || [];\r\n    let hasTrailingSlash;\r\n    let up = 0;\r\n    const toParts = to && to.split('/') || [];\r\n    const isToAbs = to && isAbsolute(to);\r\n    const isFromAbs = from && isAbsolute(from);\r\n    const mustEndAbs = isToAbs || isFromAbs;\r\n    if (to && isAbsolute(to)) {\r\n        // to is absolute\r\n        fromParts = toParts;\r\n    }\r\n    else if (toParts.length) {\r\n        // to is relative, drop the filename\r\n        fromParts.pop();\r\n        fromParts = fromParts.concat(toParts);\r\n    }\r\n    if (!fromParts.length) {\r\n        return '/';\r\n    }\r\n    if (fromParts.length) {\r\n        const last = fromParts[fromParts.length - 1];\r\n        hasTrailingSlash = (last === '.' || last === '..' || last === '');\r\n    }\r\n    else {\r\n        hasTrailingSlash = false;\r\n    }\r\n    for (let i = fromParts.length; i >= 0; i--) {\r\n        const part = fromParts[i];\r\n        if (part === '.') {\r\n            spliceOne(fromParts, i);\r\n        }\r\n        else if (part === '..') {\r\n            spliceOne(fromParts, i);\r\n            up++;\r\n        }\r\n        else if (up) {\r\n            spliceOne(fromParts, i);\r\n            up--;\r\n        }\r\n    }\r\n    if (!mustEndAbs) {\r\n        for (; up--; up) {\r\n            fromParts.unshift('..');\r\n        }\r\n    }\r\n    if (mustEndAbs && fromParts[0] !== '' && (!fromParts[0] || !isAbsolute(fromParts[0]))) {\r\n        fromParts.unshift('');\r\n    }\r\n    let result = fromParts.join('/');\r\n    if (hasTrailingSlash && result.substr(-1) !== '/') {\r\n        result += '/';\r\n    }\r\n    return result;\r\n};\r\nconst valueEqual = (a, b) => {\r\n    if (a === b) {\r\n        return true;\r\n    }\r\n    if (a == null || b == null) {\r\n        return false;\r\n    }\r\n    if (Array.isArray(a)) {\r\n        return Array.isArray(b) && a.length === b.length && a.every((item, index) => {\r\n            return valueEqual(item, b[index]);\r\n        });\r\n    }\r\n    const aType = typeof a;\r\n    const bType = typeof b;\r\n    if (aType !== bType) {\r\n        return false;\r\n    }\r\n    if (aType === 'object') {\r\n        const aValue = a.valueOf();\r\n        const bValue = b.valueOf();\r\n        if (aValue !== a || bValue !== b) {\r\n            return valueEqual(aValue, bValue);\r\n        }\r\n        const aKeys = Object.keys(a);\r\n        const bKeys = Object.keys(b);\r\n        if (aKeys.length !== bKeys.length) {\r\n            return false;\r\n        }\r\n        return aKeys.every((key) => {\r\n            return valueEqual(a[key], b[key]);\r\n        });\r\n    }\r\n    return false;\r\n};\r\nconst locationsAreEqual = (a, b) => {\r\n    return a.pathname === b.pathname &&\r\n        a.search === b.search &&\r\n        a.hash === b.hash &&\r\n        a.key === b.key &&\r\n        valueEqual(a.state, b.state);\r\n};\r\nconst createLocation = (path, state, key, currentLocation) => {\r\n    let location;\r\n    if (typeof path === 'string') {\r\n        // Two-arg form: push(path, state)\r\n        location = parsePath(path);\r\n        if (state !== undefined) {\r\n            location.state = state;\r\n        }\r\n    }\r\n    else {\r\n        // One-arg form: push(location)\r\n        location = Object.assign({ pathname: '' }, path);\r\n        if (location.search && location.search.charAt(0) !== '?') {\r\n            location.search = '?' + location.search;\r\n        }\r\n        if (location.hash && location.hash.charAt(0) !== '#') {\r\n            location.hash = '#' + location.hash;\r\n        }\r\n        if (state !== undefined && location.state === undefined) {\r\n            location.state = state;\r\n        }\r\n    }\r\n    try {\r\n        location.pathname = decodeURI(location.pathname);\r\n    }\r\n    catch (e) {\r\n        if (e instanceof URIError) {\r\n            throw new URIError('Pathname \"' + location.pathname + '\" could not be decoded. ' +\r\n                'This is likely caused by an invalid percent-encoding.');\r\n        }\r\n        else {\r\n            throw e;\r\n        }\r\n    }\r\n    location.key = key;\r\n    if (currentLocation) {\r\n        // Resolve incomplete/relative pathname relative to current location.\r\n        if (!location.pathname) {\r\n            location.pathname = currentLocation.pathname;\r\n        }\r\n        else if (location.pathname.charAt(0) !== '/') {\r\n            location.pathname = resolvePathname(location.pathname, currentLocation.pathname);\r\n        }\r\n    }\r\n    else {\r\n        // When there is no prior location and pathname is empty, set it to /\r\n        if (!location.pathname) {\r\n            location.pathname = '/';\r\n        }\r\n    }\r\n    location.query = parseQueryString(location.search || '');\r\n    return location;\r\n};\n\nexport { addLeadingSlash as a, createKey as b, createLocation as c, stripBasename as d, createPath as e, stripLeadingSlash as f, hasBasename as h, locationsAreEqual as l, stripTrailingSlash as s, valueEqual as v };\n","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nexport default function _toArray(arr) {\n  return arrayWithHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableRest();\n}","import { v as valueEqual } from './location-utils-312665d3.js';\n\n/**\r\n * TS adaption of https://github.com/pillarjs/path-to-regexp/blob/master/index.js\r\n */\r\n/**\r\n * Default configs.\r\n */\r\nconst DEFAULT_DELIMITER = '/';\r\nconst DEFAULT_DELIMITERS = './';\r\n/**\r\n * The main path matching regexp utility.\r\n */\r\nconst PATH_REGEXP = new RegExp([\r\n    // Match escaped characters that would otherwise appear in future matches.\r\n    // This allows the user to escape special characters that won't transform.\r\n    '(\\\\\\\\.)',\r\n    // Match Express-style parameters and un-named parameters with a prefix\r\n    // and optional suffixes. Matches appear as:\r\n    //\r\n    // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\"]\r\n    // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined]\r\n    '(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?'\r\n].join('|'), 'g');\r\n/**\r\n * Parse a string for the raw tokens.\r\n */\r\nconst parse = (str, options) => {\r\n    var tokens = [];\r\n    var key = 0;\r\n    var index = 0;\r\n    var path = '';\r\n    var defaultDelimiter = (options && options.delimiter) || DEFAULT_DELIMITER;\r\n    var delimiters = (options && options.delimiters) || DEFAULT_DELIMITERS;\r\n    var pathEscaped = false;\r\n    var res;\r\n    while ((res = PATH_REGEXP.exec(str)) !== null) {\r\n        var m = res[0];\r\n        var escaped = res[1];\r\n        var offset = res.index;\r\n        path += str.slice(index, offset);\r\n        index = offset + m.length;\r\n        // Ignore already escaped sequences.\r\n        if (escaped) {\r\n            path += escaped[1];\r\n            pathEscaped = true;\r\n            continue;\r\n        }\r\n        var prev = '';\r\n        var next = str[index];\r\n        var name = res[2];\r\n        var capture = res[3];\r\n        var group = res[4];\r\n        var modifier = res[5];\r\n        if (!pathEscaped && path.length) {\r\n            var k = path.length - 1;\r\n            if (delimiters.indexOf(path[k]) > -1) {\r\n                prev = path[k];\r\n                path = path.slice(0, k);\r\n            }\r\n        }\r\n        // Push the current path onto the tokens.\r\n        if (path) {\r\n            tokens.push(path);\r\n            path = '';\r\n            pathEscaped = false;\r\n        }\r\n        var partial = prev !== '' && next !== undefined && next !== prev;\r\n        var repeat = modifier === '+' || modifier === '*';\r\n        var optional = modifier === '?' || modifier === '*';\r\n        var delimiter = prev || defaultDelimiter;\r\n        var pattern = capture || group;\r\n        tokens.push({\r\n            name: name || key++,\r\n            prefix: prev,\r\n            delimiter: delimiter,\r\n            optional: optional,\r\n            repeat: repeat,\r\n            partial: partial,\r\n            pattern: pattern ? escapeGroup(pattern) : '[^' + escapeString(delimiter) + ']+?'\r\n        });\r\n    }\r\n    // Push any remaining characters.\r\n    if (path || index < str.length) {\r\n        tokens.push(path + str.substr(index));\r\n    }\r\n    return tokens;\r\n};\r\n/**\r\n * Escape a regular expression string.\r\n */\r\nconst escapeString = (str) => {\r\n    return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, '\\\\$1');\r\n};\r\n/**\r\n * Escape the capturing group by escaping special characters and meaning.\r\n */\r\nconst escapeGroup = (group) => {\r\n    return group.replace(/([=!:$/()])/g, '\\\\$1');\r\n};\r\n/**\r\n * Get the flags for a regexp from the options.\r\n */\r\nconst flags = (options) => {\r\n    return options && options.sensitive ? '' : 'i';\r\n};\r\n/**\r\n * Pull out keys from a regexp.\r\n */\r\nconst regexpToRegexp = (path, keys) => {\r\n    if (!keys)\r\n        return path;\r\n    // Use a negative lookahead to match only capturing groups.\r\n    var groups = path.source.match(/\\((?!\\?)/g);\r\n    if (groups) {\r\n        for (var i = 0; i < groups.length; i++) {\r\n            keys.push({\r\n                name: i,\r\n                prefix: null,\r\n                delimiter: null,\r\n                optional: false,\r\n                repeat: false,\r\n                partial: false,\r\n                pattern: null\r\n            });\r\n        }\r\n    }\r\n    return path;\r\n};\r\n/**\r\n * Transform an array into a regexp.\r\n */\r\nconst arrayToRegexp = (path, keys, options) => {\r\n    var parts = [];\r\n    for (var i = 0; i < path.length; i++) {\r\n        parts.push(pathToRegexp(path[i], keys, options).source);\r\n    }\r\n    return new RegExp('(?:' + parts.join('|') + ')', flags(options));\r\n};\r\n/**\r\n * Create a path regexp from string input.\r\n */\r\nconst stringToRegexp = (path, keys, options) => {\r\n    return tokensToRegExp(parse(path, options), keys, options);\r\n};\r\n/**\r\n * Expose a function for taking tokens and returning a RegExp.\r\n */\r\nconst tokensToRegExp = (tokens, keys, options) => {\r\n    options = options || {};\r\n    var strict = options.strict;\r\n    var end = options.end !== false;\r\n    var delimiter = escapeString(options.delimiter || DEFAULT_DELIMITER);\r\n    var delimiters = options.delimiters || DEFAULT_DELIMITERS;\r\n    var endsWith = [].concat(options.endsWith || []).map(escapeString).concat('$').join('|');\r\n    var route = '';\r\n    var isEndDelimited = false;\r\n    // Iterate over the tokens and create our regexp string.\r\n    for (var i = 0; i < tokens.length; i++) {\r\n        var token = tokens[i];\r\n        if (typeof token === 'string') {\r\n            route += escapeString(token);\r\n            isEndDelimited = i === tokens.length - 1 && delimiters.indexOf(token[token.length - 1]) > -1;\r\n        }\r\n        else {\r\n            var prefix = escapeString(token.prefix || '');\r\n            var capture = token.repeat\r\n                ? '(?:' + token.pattern + ')(?:' + prefix + '(?:' + token.pattern + '))*'\r\n                : token.pattern;\r\n            if (keys)\r\n                keys.push(token);\r\n            if (token.optional) {\r\n                if (token.partial) {\r\n                    route += prefix + '(' + capture + ')?';\r\n                }\r\n                else {\r\n                    route += '(?:' + prefix + '(' + capture + '))?';\r\n                }\r\n            }\r\n            else {\r\n                route += prefix + '(' + capture + ')';\r\n            }\r\n        }\r\n    }\r\n    if (end) {\r\n        if (!strict)\r\n            route += '(?:' + delimiter + ')?';\r\n        route += endsWith === '$' ? '$' : '(?=' + endsWith + ')';\r\n    }\r\n    else {\r\n        if (!strict)\r\n            route += '(?:' + delimiter + '(?=' + endsWith + '))?';\r\n        if (!isEndDelimited)\r\n            route += '(?=' + delimiter + '|' + endsWith + ')';\r\n    }\r\n    return new RegExp('^' + route, flags(options));\r\n};\r\n/**\r\n * Normalize the given path string, returning a regular expression.\r\n *\r\n * An empty array can be passed in for the keys, which will hold the\r\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\r\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\r\n */\r\nconst pathToRegexp = (path, keys, options) => {\r\n    if (path instanceof RegExp) {\r\n        return regexpToRegexp(path, keys);\r\n    }\r\n    if (Array.isArray(path)) {\r\n        return arrayToRegexp(path, keys, options);\r\n    }\r\n    return stringToRegexp(path, keys, options);\r\n};\n\nlet cacheCount = 0;\r\nconst patternCache = {};\r\nconst cacheLimit = 10000;\r\n// Memoized function for creating the path match regex\r\nconst compilePath = (pattern, options) => {\r\n    const cacheKey = `${options.end}${options.strict}`;\r\n    const cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});\r\n    const cachePattern = JSON.stringify(pattern);\r\n    if (cache[cachePattern]) {\r\n        return cache[cachePattern];\r\n    }\r\n    const keys = [];\r\n    const re = pathToRegexp(pattern, keys, options);\r\n    const compiledPattern = { re, keys };\r\n    if (cacheCount < cacheLimit) {\r\n        cache[cachePattern] = compiledPattern;\r\n        cacheCount += 1;\r\n    }\r\n    return compiledPattern;\r\n};\r\n/**\r\n * Public API for matching a URL pathname to a path pattern.\r\n */\r\nconst matchPath = (pathname, options = {}) => {\r\n    if (typeof options === 'string') {\r\n        options = { path: options };\r\n    }\r\n    const { path = '/', exact = false, strict = false } = options;\r\n    const { re, keys } = compilePath(path, { end: exact, strict });\r\n    const match = re.exec(pathname);\r\n    if (!match) {\r\n        return null;\r\n    }\r\n    const [url, ...values] = match;\r\n    const isExact = pathname === url;\r\n    if (exact && !isExact) {\r\n        return null;\r\n    }\r\n    return {\r\n        path,\r\n        url: path === '/' && url === '' ? '/' : url,\r\n        isExact,\r\n        params: keys.reduce((memo, key, index) => {\r\n            memo[key.name] = values[index];\r\n            return memo;\r\n        }, {})\r\n    };\r\n};\r\nconst matchesAreEqual = (a, b) => {\r\n    if (a == null && b == null) {\r\n        return true;\r\n    }\r\n    if (b == null) {\r\n        return false;\r\n    }\r\n    return a && b &&\r\n        a.path === b.path &&\r\n        a.url === b.url &&\r\n        valueEqual(a.params, b.params);\r\n};\n\nexport { matchesAreEqual as a, matchPath as m };\n","import { r as registerInstance, h, g as getElement } from './index-83665fc4.js';\nimport { m as matchPath } from './match-path-4b5c7d98.js';\nimport { i as isModifiedEvent } from './dom-utils-109a7d75.js';\nimport { A as ActiveRouter } from './active-router-d073ec9d.js';\nimport './location-utils-312665d3.js';\n\nconst getUrl = (url, root) => {\n  // Don't allow double slashes\n  if (url.charAt(0) == '/' && root.charAt(root.length - 1) == '/') {\n    return root.slice(0, root.length - 1) + url;\n  }\n  return root + url;\n};\nlet RouteLink = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n    this.unsubscribe = () => { return; };\n    this.activeClass = 'link-active';\n    this.exact = false;\n    this.strict = true;\n    /**\n      *  Custom tag to use instead of an anchor\n      */\n    this.custom = 'a';\n    this.match = null;\n  }\n  componentWillLoad() {\n    this.computeMatch();\n  }\n  // Identify if the current route is a match.\n  computeMatch() {\n    if (this.location) {\n      this.match = matchPath(this.location.pathname, {\n        path: this.urlMatch || this.url,\n        exact: this.exact,\n        strict: this.strict\n      });\n    }\n  }\n  handleClick(e) {\n    if (isModifiedEvent(e) || !this.history || !this.url || !this.root) {\n      return;\n    }\n    e.preventDefault();\n    return this.history.push(getUrl(this.url, this.root));\n  }\n  // Get the URL for this route link without the root from the router\n  render() {\n    let anchorAttributes = {\n      class: {\n        [this.activeClass]: this.match !== null,\n      },\n      onClick: this.handleClick.bind(this)\n    };\n    if (this.anchorClass) {\n      anchorAttributes.class[this.anchorClass] = true;\n    }\n    if (this.custom === 'a') {\n      anchorAttributes = Object.assign({}, anchorAttributes, { href: this.url, title: this.anchorTitle, role: this.anchorRole, tabindex: this.anchorTabIndex, 'aria-haspopup': this.ariaHaspopup, id: this.anchorId, 'aria-posinset': this.ariaPosinset, 'aria-setsize': this.ariaSetsize, 'aria-label': this.ariaLabel });\n    }\n    return (h(this.custom, Object.assign({}, anchorAttributes), h(\"slot\", null)));\n  }\n  get el() { return getElement(this); }\n  static get watchers() { return {\n    \"location\": [\"computeMatch\"]\n  }; }\n};\nActiveRouter.injectProps(RouteLink, [\n  'history',\n  'location',\n  'root'\n]);\n\nexport { RouteLink as stencil_route_link };\n","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}"],"names":["ActiveRouter","defaultState","consumerRender","listeners","Map","currentState","updateListener","fields","instance","Array","isArray","forEach","fieldName","Object","assign","subscribe","propList","has","set","delete","Provider","children","state","Consumer","props","injectProps","Cstr","fieldList","CstrPrototype","prototype","cstrConnectedCallback","connectedCallback","cstrDisconnectedCallback","disconnectedCallback","this","call","createProviderConsumer","historyType","location","pathname","query","key","titleSuffix","root","routeViewsUpdated","child","h","renderer","getConfirmation","win","message","callback","confirm","isModifiedEvent","ev","metaKey","altKey","ctrlKey","shiftKey","supportsHistory","ua","navigator","userAgent","indexOf","history","supportsPopStateOnHashChange","nav","supportsGoWithoutReloadUsingHash","isExtraneousPopstateEvent","event","undefined","storageAvailable","type","storage","x","setItem","removeItem","e","DOMException","code","name","length","hasBasename","path","prefix","RegExp","test","stripBasename","substr","stripTrailingSlash","charAt","slice","addLeadingSlash","stripLeadingSlash","createPath","search","hash","isAbsolute","createKey","keyLength","Math","random","toString","spliceOne","list","index","i","k","n","pop","valueEqual","a","b","every","item","aType","aValue","valueOf","bValue","aKeys","keys","bKeys","locationsAreEqual","createLocation","currentLocation","hashIndex","searchIndex","parsePath","decodeURI","URIError","to","hasTrailingSlash","from","fromParts","split","up","toParts","isToAbs","isFromAbs","mustEndAbs","concat","last","part","unshift","result","join","resolvePathname","reduce","params","param","value","decodeURIComponent","replace","_toArray","arr","arrayWithHoles","iterableToArray","unsupportedIterableToArray","nonIterableRest","PATH_REGEXP","escapeString","str","escapeGroup","group","flags","options","sensitive","arrayToRegexp","parts","push","pathToRegexp","source","stringToRegexp","tokensToRegExp","res","tokens","defaultDelimiter","delimiter","delimiters","pathEscaped","exec","m","escaped","offset","prev","next","capture","modifier","partial","repeat","optional","pattern","parse","strict","end","endsWith","map","route","isEndDelimited","token","groups","match","regexpToRegexp","cacheCount","patternCache","compilePath","cacheKey","cache","cachePattern","JSON","stringify","compiledPattern","re","matchPath","exact","url","values","isExact","memo","matchesAreEqual","RouteLink","hostRef","registerInstance","unsubscribe","activeClass","custom","computeMatch","urlMatch","preventDefault","obj","anchorAttributes","class","defineProperty","enumerable","configurable","writable","onClick","handleClick","bind","anchorClass","href","title","anchorTitle","role","anchorRole","tabindex","anchorTabIndex","ariaHaspopup","id","anchorId","ariaPosinset","ariaSetsize","ariaLabel","getElement"],"sourceRoot":""}