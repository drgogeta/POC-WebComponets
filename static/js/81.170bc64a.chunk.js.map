{"version":3,"file":"static/js/81.170bc64a.chunk.js","mappings":"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","sources":["../../app-1/dist/esm/active-router-d073ec9d.js","../../app-1/dist/esm/dom-utils-109a7d75.js","../../app-1/dist/esm/location-utils-312665d3.js","../../app-1/dist/esm/stencil-router.entry.js"],"sourcesContent":["import { h } from './index-83665fc4.js';\n\nconst createProviderConsumer = (defaultState, consumerRender) => {\r\n    let listeners = new Map();\r\n    let currentState = defaultState;\r\n    const updateListener = (fields, instance) => {\r\n        if (Array.isArray(fields)) {\r\n            [...fields].forEach(fieldName => {\r\n                instance[fieldName] = currentState[fieldName];\r\n            });\r\n        }\r\n        else {\r\n            instance[fields] = Object.assign({}, currentState);\r\n        }\r\n    };\r\n    const subscribe = (instance, propList) => {\r\n        if (!listeners.has(instance)) {\r\n            listeners.set(instance, propList);\r\n            updateListener(propList, instance);\r\n        }\r\n        return () => {\r\n            if (listeners.has(instance)) {\r\n                listeners.delete(instance);\r\n            }\r\n        };\r\n    };\r\n    const Provider = ({ state }, children) => {\r\n        currentState = state;\r\n        listeners.forEach(updateListener);\r\n        return children;\r\n    };\r\n    const Consumer = (props, children) => {\r\n        // The casting on subscribe is to allow for crossover through the stencil compiler\r\n        // In the future we should allow for generics in components.\r\n        return consumerRender(subscribe, children[0]);\r\n    };\r\n    const injectProps = (Cstr, fieldList) => {\r\n        const CstrPrototype = Cstr.prototype;\r\n        const cstrConnectedCallback = CstrPrototype.connectedCallback;\r\n        const cstrDisconnectedCallback = CstrPrototype.disconnectedCallback;\r\n        CstrPrototype.connectedCallback = function () {\r\n            subscribe(this, fieldList);\r\n            if (cstrConnectedCallback) {\r\n                return cstrConnectedCallback.call(this);\r\n            }\r\n        };\r\n        CstrPrototype.disconnectedCallback = function () {\r\n            listeners.delete(this);\r\n            if (cstrDisconnectedCallback) {\r\n                cstrDisconnectedCallback.call(this);\r\n            }\r\n        };\r\n    };\r\n    return {\r\n        Provider,\r\n        Consumer,\r\n        injectProps\r\n    };\r\n};\n\nconst ActiveRouter = createProviderConsumer({\r\n    historyType: 'browser',\r\n    location: {\r\n        pathname: '',\r\n        query: {},\r\n        key: ''\r\n    },\r\n    titleSuffix: '',\r\n    root: '/',\r\n    routeViewsUpdated: () => { }\r\n}, (subscribe, child) => (h(\"context-consumer\", { subscribe: subscribe, renderer: child })));\n\nexport { ActiveRouter as A };\n","const getConfirmation = (win, message, callback) => (callback(win.confirm(message)));\r\nconst isModifiedEvent = (ev) => (ev.metaKey || ev.altKey || ev.ctrlKey || ev.shiftKey);\r\n/**\r\n * Returns true if the HTML5 history API is supported. Taken from Modernizr.\r\n *\r\n * https://github.com/Modernizr/Modernizr/blob/master/LICENSE\r\n * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js\r\n * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586\r\n */\r\nconst supportsHistory = (win) => {\r\n    const ua = win.navigator.userAgent;\r\n    if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&\r\n        ua.indexOf('Mobile Safari') !== -1 &&\r\n        ua.indexOf('Chrome') === -1 &&\r\n        ua.indexOf('Windows Phone') === -1) {\r\n        return false;\r\n    }\r\n    return win.history && 'pushState' in win.history;\r\n};\r\n/**\r\n * Returns true if browser fires popstate on hash change.\r\n * IE10 and IE11 do not.\r\n */\r\nconst supportsPopStateOnHashChange = (nav) => (nav.userAgent.indexOf('Trident') === -1);\r\n/**\r\n * Returns false if using go(n) with hash history causes a full page reload.\r\n */\r\nconst supportsGoWithoutReloadUsingHash = (nav) => (nav.userAgent.indexOf('Firefox') === -1);\r\nconst isExtraneousPopstateEvent = (nav, event) => (event.state === undefined &&\r\n    nav.userAgent.indexOf('CriOS') === -1);\r\nconst storageAvailable = (win, type) => {\r\n    const storage = win[type];\r\n    const x = '__storage_test__';\r\n    try {\r\n        storage.setItem(x, x);\r\n        storage.removeItem(x);\r\n        return true;\r\n    }\r\n    catch (e) {\r\n        return e instanceof DOMException && (\r\n        // everything except Firefox\r\n        e.code === 22 ||\r\n            // Firefox\r\n            e.code === 1014 ||\r\n            // test name field too, because code might not be present\r\n            // everything except Firefox\r\n            e.name === 'QuotaExceededError' ||\r\n            // Firefox\r\n            e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&\r\n            // acknowledge QuotaExceededError only if there's something already stored\r\n            storage.length !== 0;\r\n    }\r\n};\n\nexport { supportsHistory as a, supportsPopStateOnHashChange as b, isExtraneousPopstateEvent as c, supportsGoWithoutReloadUsingHash as d, getConfirmation as g, isModifiedEvent as i, storageAvailable as s };\n","const hasBasename = (path, prefix) => {\r\n    return (new RegExp('^' + prefix + '(\\\\/|\\\\?|#|$)', 'i')).test(path);\r\n};\r\nconst stripBasename = (path, prefix) => {\r\n    return hasBasename(path, prefix) ? path.substr(prefix.length) : path;\r\n};\r\nconst stripTrailingSlash = (path) => {\r\n    return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;\r\n};\r\nconst addLeadingSlash = (path) => {\r\n    return path.charAt(0) === '/' ? path : '/' + path;\r\n};\r\nconst stripLeadingSlash = (path) => {\r\n    return path.charAt(0) === '/' ? path.substr(1) : path;\r\n};\r\nconst parsePath = (path) => {\r\n    let pathname = path || '/';\r\n    let search = '';\r\n    let hash = '';\r\n    const hashIndex = pathname.indexOf('#');\r\n    if (hashIndex !== -1) {\r\n        hash = pathname.substr(hashIndex);\r\n        pathname = pathname.substr(0, hashIndex);\r\n    }\r\n    const searchIndex = pathname.indexOf('?');\r\n    if (searchIndex !== -1) {\r\n        search = pathname.substr(searchIndex);\r\n        pathname = pathname.substr(0, searchIndex);\r\n    }\r\n    return {\r\n        pathname,\r\n        search: search === '?' ? '' : search,\r\n        hash: hash === '#' ? '' : hash,\r\n        query: {},\r\n        key: ''\r\n    };\r\n};\r\nconst createPath = (location) => {\r\n    const { pathname, search, hash } = location;\r\n    let path = pathname || '/';\r\n    if (search && search !== '?') {\r\n        path += (search.charAt(0) === '?' ? search : `?${search}`);\r\n    }\r\n    if (hash && hash !== '#') {\r\n        path += (hash.charAt(0) === '#' ? hash : `#${hash}`);\r\n    }\r\n    return path;\r\n};\r\nconst parseQueryString = (query) => {\r\n    if (!query) {\r\n        return {};\r\n    }\r\n    return (/^[?#]/.test(query) ? query.slice(1) : query)\r\n        .split('&')\r\n        .reduce((params, param) => {\r\n        let [key, value] = param.split('=');\r\n        params[key] = value ? decodeURIComponent(value.replace(/\\+/g, ' ')) : '';\r\n        return params;\r\n    }, {});\r\n};\n\nconst isAbsolute = (pathname) => {\r\n    return pathname.charAt(0) === '/';\r\n};\r\nconst createKey = (keyLength) => {\r\n    return Math.random().toString(36).substr(2, keyLength);\r\n};\r\n// About 1.5x faster than the two-arg version of Array#splice()\r\nconst spliceOne = (list, index) => {\r\n    for (let i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {\r\n        list[i] = list[k];\r\n    }\r\n    list.pop();\r\n};\r\n// This implementation is based heavily on node's url.parse\r\nconst resolvePathname = (to, from = '') => {\r\n    let fromParts = from && from.split('/') || [];\r\n    let hasTrailingSlash;\r\n    let up = 0;\r\n    const toParts = to && to.split('/') || [];\r\n    const isToAbs = to && isAbsolute(to);\r\n    const isFromAbs = from && isAbsolute(from);\r\n    const mustEndAbs = isToAbs || isFromAbs;\r\n    if (to && isAbsolute(to)) {\r\n        // to is absolute\r\n        fromParts = toParts;\r\n    }\r\n    else if (toParts.length) {\r\n        // to is relative, drop the filename\r\n        fromParts.pop();\r\n        fromParts = fromParts.concat(toParts);\r\n    }\r\n    if (!fromParts.length) {\r\n        return '/';\r\n    }\r\n    if (fromParts.length) {\r\n        const last = fromParts[fromParts.length - 1];\r\n        hasTrailingSlash = (last === '.' || last === '..' || last === '');\r\n    }\r\n    else {\r\n        hasTrailingSlash = false;\r\n    }\r\n    for (let i = fromParts.length; i >= 0; i--) {\r\n        const part = fromParts[i];\r\n        if (part === '.') {\r\n            spliceOne(fromParts, i);\r\n        }\r\n        else if (part === '..') {\r\n            spliceOne(fromParts, i);\r\n            up++;\r\n        }\r\n        else if (up) {\r\n            spliceOne(fromParts, i);\r\n            up--;\r\n        }\r\n    }\r\n    if (!mustEndAbs) {\r\n        for (; up--; up) {\r\n            fromParts.unshift('..');\r\n        }\r\n    }\r\n    if (mustEndAbs && fromParts[0] !== '' && (!fromParts[0] || !isAbsolute(fromParts[0]))) {\r\n        fromParts.unshift('');\r\n    }\r\n    let result = fromParts.join('/');\r\n    if (hasTrailingSlash && result.substr(-1) !== '/') {\r\n        result += '/';\r\n    }\r\n    return result;\r\n};\r\nconst valueEqual = (a, b) => {\r\n    if (a === b) {\r\n        return true;\r\n    }\r\n    if (a == null || b == null) {\r\n        return false;\r\n    }\r\n    if (Array.isArray(a)) {\r\n        return Array.isArray(b) && a.length === b.length && a.every((item, index) => {\r\n            return valueEqual(item, b[index]);\r\n        });\r\n    }\r\n    const aType = typeof a;\r\n    const bType = typeof b;\r\n    if (aType !== bType) {\r\n        return false;\r\n    }\r\n    if (aType === 'object') {\r\n        const aValue = a.valueOf();\r\n        const bValue = b.valueOf();\r\n        if (aValue !== a || bValue !== b) {\r\n            return valueEqual(aValue, bValue);\r\n        }\r\n        const aKeys = Object.keys(a);\r\n        const bKeys = Object.keys(b);\r\n        if (aKeys.length !== bKeys.length) {\r\n            return false;\r\n        }\r\n        return aKeys.every((key) => {\r\n            return valueEqual(a[key], b[key]);\r\n        });\r\n    }\r\n    return false;\r\n};\r\nconst locationsAreEqual = (a, b) => {\r\n    return a.pathname === b.pathname &&\r\n        a.search === b.search &&\r\n        a.hash === b.hash &&\r\n        a.key === b.key &&\r\n        valueEqual(a.state, b.state);\r\n};\r\nconst createLocation = (path, state, key, currentLocation) => {\r\n    let location;\r\n    if (typeof path === 'string') {\r\n        // Two-arg form: push(path, state)\r\n        location = parsePath(path);\r\n        if (state !== undefined) {\r\n            location.state = state;\r\n        }\r\n    }\r\n    else {\r\n        // One-arg form: push(location)\r\n        location = Object.assign({ pathname: '' }, path);\r\n        if (location.search && location.search.charAt(0) !== '?') {\r\n            location.search = '?' + location.search;\r\n        }\r\n        if (location.hash && location.hash.charAt(0) !== '#') {\r\n            location.hash = '#' + location.hash;\r\n        }\r\n        if (state !== undefined && location.state === undefined) {\r\n            location.state = state;\r\n        }\r\n    }\r\n    try {\r\n        location.pathname = decodeURI(location.pathname);\r\n    }\r\n    catch (e) {\r\n        if (e instanceof URIError) {\r\n            throw new URIError('Pathname \"' + location.pathname + '\" could not be decoded. ' +\r\n                'This is likely caused by an invalid percent-encoding.');\r\n        }\r\n        else {\r\n            throw e;\r\n        }\r\n    }\r\n    location.key = key;\r\n    if (currentLocation) {\r\n        // Resolve incomplete/relative pathname relative to current location.\r\n        if (!location.pathname) {\r\n            location.pathname = currentLocation.pathname;\r\n        }\r\n        else if (location.pathname.charAt(0) !== '/') {\r\n            location.pathname = resolvePathname(location.pathname, currentLocation.pathname);\r\n        }\r\n    }\r\n    else {\r\n        // When there is no prior location and pathname is empty, set it to /\r\n        if (!location.pathname) {\r\n            location.pathname = '/';\r\n        }\r\n    }\r\n    location.query = parseQueryString(location.search || '');\r\n    return location;\r\n};\n\nexport { addLeadingSlash as a, createKey as b, createLocation as c, stripBasename as d, createPath as e, stripLeadingSlash as f, hasBasename as h, locationsAreEqual as l, stripTrailingSlash as s, valueEqual as v };\n","import { r as registerInstance, a as getContext, h, g as getElement } from './index-83665fc4.js';\nimport { s as stripTrailingSlash, a as addLeadingSlash, c as createLocation, b as createKey, h as hasBasename, d as stripBasename, e as createPath, f as stripLeadingSlash, l as locationsAreEqual } from './location-utils-312665d3.js';\nimport { s as storageAvailable, a as supportsHistory, b as supportsPopStateOnHashChange, g as getConfirmation, c as isExtraneousPopstateEvent, d as supportsGoWithoutReloadUsingHash } from './dom-utils-109a7d75.js';\nimport { A as ActiveRouter } from './active-router-d073ec9d.js';\n\nconst warning = (value, ...args) => {\r\n    if (!value) {\r\n        console.warn(...args);\r\n    }\r\n};\n\n// Adapted from the https://github.com/ReactTraining/history and converted to TypeScript\r\nconst createTransitionManager = () => {\r\n    let prompt;\r\n    let listeners = [];\r\n    const setPrompt = (nextPrompt) => {\r\n        warning(prompt == null, 'A history supports only one prompt at a time');\r\n        prompt = nextPrompt;\r\n        return () => {\r\n            if (prompt === nextPrompt) {\r\n                prompt = null;\r\n            }\r\n        };\r\n    };\r\n    const confirmTransitionTo = (location, action, getUserConfirmation, callback) => {\r\n        // TODO: If another transition starts while we're still confirming\r\n        // the previous one, we may end up in a weird state. Figure out the\r\n        // best way to handle this.\r\n        if (prompt != null) {\r\n            const result = typeof prompt === 'function' ? prompt(location, action) : prompt;\r\n            if (typeof result === 'string') {\r\n                if (typeof getUserConfirmation === 'function') {\r\n                    getUserConfirmation(result, callback);\r\n                }\r\n                else {\r\n                    warning(false, 'A history needs a getUserConfirmation function in order to use a prompt message');\r\n                    callback(true);\r\n                }\r\n            }\r\n            else {\r\n                // Return false from a transition hook to cancel the transition.\r\n                callback(result !== false);\r\n            }\r\n        }\r\n        else {\r\n            callback(true);\r\n        }\r\n    };\r\n    const appendListener = (fn) => {\r\n        let isActive = true;\r\n        const listener = (...args) => {\r\n            if (isActive) {\r\n                fn(...args);\r\n            }\r\n        };\r\n        listeners.push(listener);\r\n        return () => {\r\n            isActive = false;\r\n            listeners = listeners.filter(item => item !== listener);\r\n        };\r\n    };\r\n    const notifyListeners = (...args) => {\r\n        listeners.forEach(listener => listener(...args));\r\n    };\r\n    return {\r\n        setPrompt,\r\n        confirmTransitionTo,\r\n        appendListener,\r\n        notifyListeners\r\n    };\r\n};\n\nconst createScrollHistory = (win, applicationScrollKey = 'scrollPositions') => {\r\n    let scrollPositions = new Map();\r\n    const set = (key, value) => {\r\n        scrollPositions.set(key, value);\r\n        if (storageAvailable(win, 'sessionStorage')) {\r\n            const arrayData = [];\r\n            scrollPositions.forEach((value, key) => {\r\n                arrayData.push([key, value]);\r\n            });\r\n            win.sessionStorage.setItem('scrollPositions', JSON.stringify(arrayData));\r\n        }\r\n    };\r\n    const get = (key) => {\r\n        return scrollPositions.get(key);\r\n    };\r\n    const has = (key) => {\r\n        return scrollPositions.has(key);\r\n    };\r\n    const capture = (key) => {\r\n        set(key, [win.scrollX, win.scrollY]);\r\n    };\r\n    if (storageAvailable(win, 'sessionStorage')) {\r\n        const scrollData = win.sessionStorage.getItem(applicationScrollKey);\r\n        scrollPositions = scrollData ?\r\n            new Map(JSON.parse(scrollData)) :\r\n            scrollPositions;\r\n    }\r\n    if ('scrollRestoration' in win.history) {\r\n        history.scrollRestoration = 'manual';\r\n    }\r\n    return {\r\n        set,\r\n        get,\r\n        has,\r\n        capture\r\n    };\r\n};\n\n// Adapted from the https://github.com/ReactTraining/history and converted to TypeScript\r\nconst PopStateEvent = 'popstate';\r\nconst HashChangeEvent$1 = 'hashchange';\r\n/**\r\n * Creates a history object that uses the HTML5 history API including\r\n * pushState, replaceState, and the popstate event.\r\n */\r\nconst createBrowserHistory = (win, props = {}) => {\r\n    let forceNextPop = false;\r\n    const globalHistory = win.history;\r\n    const globalLocation = win.location;\r\n    const globalNavigator = win.navigator;\r\n    const canUseHistory = supportsHistory(win);\r\n    const needsHashChangeListener = !supportsPopStateOnHashChange(globalNavigator);\r\n    const scrollHistory = createScrollHistory(win);\r\n    const forceRefresh = (props.forceRefresh != null) ? props.forceRefresh : false;\r\n    const getUserConfirmation = (props.getUserConfirmation != null) ? props.getUserConfirmation : getConfirmation;\r\n    const keyLength = (props.keyLength != null) ? props.keyLength : 6;\r\n    const basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';\r\n    const getHistoryState = () => {\r\n        try {\r\n            return win.history.state || {};\r\n        }\r\n        catch (e) {\r\n            // IE 11 sometimes throws when accessing window.history.state\r\n            // See https://github.com/ReactTraining/history/pull/289\r\n            return {};\r\n        }\r\n    };\r\n    const getDOMLocation = (historyState) => {\r\n        historyState = historyState || {};\r\n        const { key, state } = historyState;\r\n        const { pathname, search, hash } = globalLocation;\r\n        let path = pathname + search + hash;\r\n        warning((!basename || hasBasename(path, basename)), 'You are attempting to use a basename on a page whose URL path does not begin ' +\r\n            'with the basename. Expected path \"' + path + '\" to begin with \"' + basename + '\".');\r\n        if (basename) {\r\n            path = stripBasename(path, basename);\r\n        }\r\n        return createLocation(path, state, key || createKey(keyLength));\r\n    };\r\n    const transitionManager = createTransitionManager();\r\n    const setState = (nextState) => {\r\n        // Capture location for the view before changing history.\r\n        scrollHistory.capture(history.location.key);\r\n        Object.assign(history, nextState);\r\n        // Set scroll position based on its previous storage value\r\n        history.location.scrollPosition = scrollHistory.get(history.location.key);\r\n        history.length = globalHistory.length;\r\n        transitionManager.notifyListeners(history.location, history.action);\r\n    };\r\n    const handlePopState = (event) => {\r\n        // Ignore extraneous popstate events in WebKit.\r\n        if (!isExtraneousPopstateEvent(globalNavigator, event)) {\r\n            handlePop(getDOMLocation(event.state));\r\n        }\r\n    };\r\n    const handleHashChange = () => {\r\n        handlePop(getDOMLocation(getHistoryState()));\r\n    };\r\n    const handlePop = (location) => {\r\n        if (forceNextPop) {\r\n            forceNextPop = false;\r\n            setState();\r\n        }\r\n        else {\r\n            const action = 'POP';\r\n            transitionManager.confirmTransitionTo(location, action, getUserConfirmation, (ok) => {\r\n                if (ok) {\r\n                    setState({ action, location });\r\n                }\r\n                else {\r\n                    revertPop(location);\r\n                }\r\n            });\r\n        }\r\n    };\r\n    const revertPop = (fromLocation) => {\r\n        const toLocation = history.location;\r\n        // TODO: We could probably make this more reliable by\r\n        // keeping a list of keys we've seen in sessionStorage.\r\n        // Instead, we just default to 0 for keys we don't know.\r\n        let toIndex = allKeys.indexOf(toLocation.key);\r\n        let fromIndex = allKeys.indexOf(fromLocation.key);\r\n        if (toIndex === -1) {\r\n            toIndex = 0;\r\n        }\r\n        if (fromIndex === -1) {\r\n            fromIndex = 0;\r\n        }\r\n        const delta = toIndex - fromIndex;\r\n        if (delta) {\r\n            forceNextPop = true;\r\n            go(delta);\r\n        }\r\n    };\r\n    const initialLocation = getDOMLocation(getHistoryState());\r\n    let allKeys = [initialLocation.key];\r\n    let listenerCount = 0;\r\n    let isBlocked = false;\r\n    // Public interface\r\n    const createHref = (location) => {\r\n        return basename + createPath(location);\r\n    };\r\n    const push = (path, state) => {\r\n        warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' +\r\n            'argument is a location-like object that already has state; it is ignored');\r\n        const action = 'PUSH';\r\n        const location = createLocation(path, state, createKey(keyLength), history.location);\r\n        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, (ok) => {\r\n            if (!ok) {\r\n                return;\r\n            }\r\n            const href = createHref(location);\r\n            const { key, state } = location;\r\n            if (canUseHistory) {\r\n                globalHistory.pushState({ key, state }, '', href);\r\n                if (forceRefresh) {\r\n                    globalLocation.href = href;\r\n                }\r\n                else {\r\n                    const prevIndex = allKeys.indexOf(history.location.key);\r\n                    const nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);\r\n                    nextKeys.push(location.key);\r\n                    allKeys = nextKeys;\r\n                    setState({ action, location });\r\n                }\r\n            }\r\n            else {\r\n                warning(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history');\r\n                globalLocation.href = href;\r\n            }\r\n        });\r\n    };\r\n    const replace = (path, state) => {\r\n        warning(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' +\r\n            'argument is a location-like object that already has state; it is ignored');\r\n        const action = 'REPLACE';\r\n        const location = createLocation(path, state, createKey(keyLength), history.location);\r\n        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, (ok) => {\r\n            if (!ok) {\r\n                return;\r\n            }\r\n            const href = createHref(location);\r\n            const { key, state } = location;\r\n            if (canUseHistory) {\r\n                globalHistory.replaceState({ key, state }, '', href);\r\n                if (forceRefresh) {\r\n                    globalLocation.replace(href);\r\n                }\r\n                else {\r\n                    const prevIndex = allKeys.indexOf(history.location.key);\r\n                    if (prevIndex !== -1) {\r\n                        allKeys[prevIndex] = location.key;\r\n                    }\r\n                    setState({ action, location });\r\n                }\r\n            }\r\n            else {\r\n                warning(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history');\r\n                globalLocation.replace(href);\r\n            }\r\n        });\r\n    };\r\n    const go = (n) => {\r\n        globalHistory.go(n);\r\n    };\r\n    const goBack = () => go(-1);\r\n    const goForward = () => go(1);\r\n    const checkDOMListeners = (delta) => {\r\n        listenerCount += delta;\r\n        if (listenerCount === 1) {\r\n            win.addEventListener(PopStateEvent, handlePopState);\r\n            if (needsHashChangeListener) {\r\n                win.addEventListener(HashChangeEvent$1, handleHashChange);\r\n            }\r\n        }\r\n        else if (listenerCount === 0) {\r\n            win.removeEventListener(PopStateEvent, handlePopState);\r\n            if (needsHashChangeListener) {\r\n                win.removeEventListener(HashChangeEvent$1, handleHashChange);\r\n            }\r\n        }\r\n    };\r\n    const block = (prompt = '') => {\r\n        const unblock = transitionManager.setPrompt(prompt);\r\n        if (!isBlocked) {\r\n            checkDOMListeners(1);\r\n            isBlocked = true;\r\n        }\r\n        return () => {\r\n            if (isBlocked) {\r\n                isBlocked = false;\r\n                checkDOMListeners(-1);\r\n            }\r\n            return unblock();\r\n        };\r\n    };\r\n    const listen = (listener) => {\r\n        const unlisten = transitionManager.appendListener(listener);\r\n        checkDOMListeners(1);\r\n        return () => {\r\n            checkDOMListeners(-1);\r\n            unlisten();\r\n        };\r\n    };\r\n    const history = {\r\n        length: globalHistory.length,\r\n        action: 'POP',\r\n        location: initialLocation,\r\n        createHref,\r\n        push,\r\n        replace,\r\n        go,\r\n        goBack,\r\n        goForward,\r\n        block,\r\n        listen,\r\n        win: win\r\n    };\r\n    return history;\r\n};\n\n// Adapted from the https://github.com/ReactTraining/history and converted to TypeScript\r\nconst HashChangeEvent = 'hashchange';\r\nconst HashPathCoders = {\r\n    hashbang: {\r\n        encodePath: (path) => path.charAt(0) === '!' ? path : '!/' + stripLeadingSlash(path),\r\n        decodePath: (path) => path.charAt(0) === '!' ? path.substr(1) : path\r\n    },\r\n    noslash: {\r\n        encodePath: stripLeadingSlash,\r\n        decodePath: addLeadingSlash\r\n    },\r\n    slash: {\r\n        encodePath: addLeadingSlash,\r\n        decodePath: addLeadingSlash\r\n    }\r\n};\r\nconst createHashHistory = (win, props = {}) => {\r\n    let forceNextPop = false;\r\n    let ignorePath = null;\r\n    let listenerCount = 0;\r\n    let isBlocked = false;\r\n    const globalLocation = win.location;\r\n    const globalHistory = win.history;\r\n    const canGoWithoutReload = supportsGoWithoutReloadUsingHash(win.navigator);\r\n    const keyLength = (props.keyLength != null) ? props.keyLength : 6;\r\n    const { getUserConfirmation = getConfirmation, hashType = 'slash' } = props;\r\n    const basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';\r\n    const { encodePath, decodePath } = HashPathCoders[hashType];\r\n    const getHashPath = () => {\r\n        // We can't use window.location.hash here because it's not\r\n        // consistent across browsers - Firefox will pre-decode it!\r\n        const href = globalLocation.href;\r\n        const hashIndex = href.indexOf('#');\r\n        return hashIndex === -1 ? '' : href.substring(hashIndex + 1);\r\n    };\r\n    const pushHashPath = (path) => (globalLocation.hash = path);\r\n    const replaceHashPath = (path) => {\r\n        const hashIndex = globalLocation.href.indexOf('#');\r\n        globalLocation.replace(globalLocation.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);\r\n    };\r\n    const getDOMLocation = () => {\r\n        let path = decodePath(getHashPath());\r\n        warning((!basename || hasBasename(path, basename)), 'You are attempting to use a basename on a page whose URL path does not begin ' +\r\n            'with the basename. Expected path \"' + path + '\" to begin with \"' + basename + '\".');\r\n        if (basename) {\r\n            path = stripBasename(path, basename);\r\n        }\r\n        return createLocation(path, undefined, createKey(keyLength));\r\n    };\r\n    const transitionManager = createTransitionManager();\r\n    const setState = (nextState) => {\r\n        Object.assign(history, nextState);\r\n        history.length = globalHistory.length;\r\n        transitionManager.notifyListeners(history.location, history.action);\r\n    };\r\n    const handleHashChange = () => {\r\n        const path = getHashPath();\r\n        const encodedPath = encodePath(path);\r\n        if (path !== encodedPath) {\r\n            // Ensure we always have a properly-encoded hash.\r\n            replaceHashPath(encodedPath);\r\n        }\r\n        else {\r\n            const location = getDOMLocation();\r\n            const prevLocation = history.location;\r\n            if (!forceNextPop && locationsAreEqual(prevLocation, location)) {\r\n                return; // A hashchange doesn't always == location change.\r\n            }\r\n            if (ignorePath === createPath(location)) {\r\n                return; // Ignore this change; we already setState in push/replace.\r\n            }\r\n            ignorePath = null;\r\n            handlePop(location);\r\n        }\r\n    };\r\n    const handlePop = (location) => {\r\n        if (forceNextPop) {\r\n            forceNextPop = false;\r\n            setState();\r\n        }\r\n        else {\r\n            const action = 'POP';\r\n            transitionManager.confirmTransitionTo(location, action, getUserConfirmation, (ok) => {\r\n                if (ok) {\r\n                    setState({ action, location });\r\n                }\r\n                else {\r\n                    revertPop(location);\r\n                }\r\n            });\r\n        }\r\n    };\r\n    const revertPop = (fromLocation) => {\r\n        const toLocation = history.location;\r\n        // TODO: We could probably make this more reliable by\r\n        // keeping a list of paths we've seen in sessionStorage.\r\n        // Instead, we just default to 0 for paths we don't know.\r\n        let toIndex = allPaths.lastIndexOf(createPath(toLocation));\r\n        let fromIndex = allPaths.lastIndexOf(createPath(fromLocation));\r\n        if (toIndex === -1) {\r\n            toIndex = 0;\r\n        }\r\n        if (fromIndex === -1) {\r\n            fromIndex = 0;\r\n        }\r\n        const delta = toIndex - fromIndex;\r\n        if (delta) {\r\n            forceNextPop = true;\r\n            go(delta);\r\n        }\r\n    };\r\n    // Ensure the hash is encoded properly before doing anything else.\r\n    const path = getHashPath();\r\n    const encodedPath = encodePath(path);\r\n    if (path !== encodedPath) {\r\n        replaceHashPath(encodedPath);\r\n    }\r\n    const initialLocation = getDOMLocation();\r\n    let allPaths = [createPath(initialLocation)];\r\n    // Public interface\r\n    const createHref = (location) => ('#' + encodePath(basename + createPath(location)));\r\n    const push = (path, state) => {\r\n        warning(state === undefined, 'Hash history cannot push state; it is ignored');\r\n        const action = 'PUSH';\r\n        const location = createLocation(path, undefined, createKey(keyLength), history.location);\r\n        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, (ok) => {\r\n            if (!ok) {\r\n                return;\r\n            }\r\n            const path = createPath(location);\r\n            const encodedPath = encodePath(basename + path);\r\n            const hashChanged = getHashPath() !== encodedPath;\r\n            if (hashChanged) {\r\n                // We cannot tell if a hashchange was caused by a PUSH, so we'd\r\n                // rather setState here and ignore the hashchange. The caveat here\r\n                // is that other hash histories in the page will consider it a POP.\r\n                ignorePath = path;\r\n                pushHashPath(encodedPath);\r\n                const prevIndex = allPaths.lastIndexOf(createPath(history.location));\r\n                const nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);\r\n                nextPaths.push(path);\r\n                allPaths = nextPaths;\r\n                setState({ action, location });\r\n            }\r\n            else {\r\n                warning(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');\r\n                setState();\r\n            }\r\n        });\r\n    };\r\n    const replace = (path, state) => {\r\n        warning(state === undefined, 'Hash history cannot replace state; it is ignored');\r\n        const action = 'REPLACE';\r\n        const location = createLocation(path, undefined, createKey(keyLength), history.location);\r\n        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, (ok) => {\r\n            if (!ok) {\r\n                return;\r\n            }\r\n            const path = createPath(location);\r\n            const encodedPath = encodePath(basename + path);\r\n            const hashChanged = getHashPath() !== encodedPath;\r\n            if (hashChanged) {\r\n                // We cannot tell if a hashchange was caused by a REPLACE, so we'd\r\n                // rather setState here and ignore the hashchange. The caveat here\r\n                // is that other hash histories in the page will consider it a POP.\r\n                ignorePath = path;\r\n                replaceHashPath(encodedPath);\r\n            }\r\n            const prevIndex = allPaths.indexOf(createPath(history.location));\r\n            if (prevIndex !== -1) {\r\n                allPaths[prevIndex] = path;\r\n            }\r\n            setState({ action, location });\r\n        });\r\n    };\r\n    const go = (n) => {\r\n        warning(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');\r\n        globalHistory.go(n);\r\n    };\r\n    const goBack = () => go(-1);\r\n    const goForward = () => go(1);\r\n    const checkDOMListeners = (win, delta) => {\r\n        listenerCount += delta;\r\n        if (listenerCount === 1) {\r\n            win.addEventListener(HashChangeEvent, handleHashChange);\r\n        }\r\n        else if (listenerCount === 0) {\r\n            win.removeEventListener(HashChangeEvent, handleHashChange);\r\n        }\r\n    };\r\n    const block = (prompt = '') => {\r\n        const unblock = transitionManager.setPrompt(prompt);\r\n        if (!isBlocked) {\r\n            checkDOMListeners(win, 1);\r\n            isBlocked = true;\r\n        }\r\n        return () => {\r\n            if (isBlocked) {\r\n                isBlocked = false;\r\n                checkDOMListeners(win, -1);\r\n            }\r\n            return unblock();\r\n        };\r\n    };\r\n    const listen = (listener) => {\r\n        const unlisten = transitionManager.appendListener(listener);\r\n        checkDOMListeners(win, 1);\r\n        return () => {\r\n            checkDOMListeners(win, -1);\r\n            unlisten();\r\n        };\r\n    };\r\n    const history = {\r\n        length: globalHistory.length,\r\n        action: 'POP',\r\n        location: initialLocation,\r\n        createHref,\r\n        push,\r\n        replace,\r\n        go,\r\n        goBack,\r\n        goForward,\r\n        block,\r\n        listen,\r\n        win: win\r\n    };\r\n    return history;\r\n};\n\nconst getLocation = (location, root) => {\n  // Remove the root URL if found at beginning of string\n  const pathname = location.pathname.indexOf(root) == 0 ?\n    '/' + location.pathname.slice(root.length) :\n    location.pathname;\n  return Object.assign({}, location, { pathname });\n};\nconst HISTORIES = {\n  'browser': createBrowserHistory,\n  'hash': createHashHistory\n};\nlet Router = class {\n  constructor(hostRef) {\n    registerInstance(this, hostRef);\n    this.root = '/';\n    this.historyType = 'browser';\n    // A suffix to append to the page title whenever\n    // it's updated through RouteTitle\n    this.titleSuffix = '';\n    this.routeViewsUpdated = (options = {}) => {\n      if (this.history && options.scrollToId && this.historyType === 'browser') {\n        const elm = this.history.win.document.getElementById(options.scrollToId);\n        if (elm) {\n          return elm.scrollIntoView();\n        }\n      }\n      this.scrollTo(options.scrollTopOffset || this.scrollTopOffset);\n    };\n    this.isServer = getContext(this, \"isServer\");\n    this.queue = getContext(this, \"queue\");\n  }\n  componentWillLoad() {\n    this.history = HISTORIES[this.historyType](this.el.ownerDocument.defaultView);\n    this.history.listen((location) => {\n      location = getLocation(location, this.root);\n      this.location = location;\n    });\n    this.location = getLocation(this.history.location, this.root);\n  }\n  scrollTo(scrollToLocation) {\n    const history = this.history;\n    if (scrollToLocation == null || this.isServer || !history) {\n      return;\n    }\n    if (history.action === 'POP' && Array.isArray(history.location.scrollPosition)) {\n      return this.queue.write(() => {\n        if (history && history.location && Array.isArray(history.location.scrollPosition)) {\n          history.win.scrollTo(history.location.scrollPosition[0], history.location.scrollPosition[1]);\n        }\n      });\n    }\n    // okay, the frame has passed. Go ahead and render now\n    return this.queue.write(() => {\n      history.win.scrollTo(0, scrollToLocation);\n    });\n  }\n  render() {\n    if (!this.location || !this.history) {\n      return;\n    }\n    const state = {\n      historyType: this.historyType,\n      location: this.location,\n      titleSuffix: this.titleSuffix,\n      root: this.root,\n      history: this.history,\n      routeViewsUpdated: this.routeViewsUpdated\n    };\n    return (h(ActiveRouter.Provider, { state: state }, h(\"slot\", null)));\n  }\n  get el() { return getElement(this); }\n};\n\nexport { Router as stencil_router };\n"],"names":["ActiveRouter","defaultState","consumerRender","listeners","Map","currentState","updateListener","fields","instance","Array","isArray","forEach","fieldName","Object","assign","subscribe","propList","has","set","delete","Provider","children","state","Consumer","props","injectProps","Cstr","fieldList","CstrPrototype","prototype","cstrConnectedCallback","connectedCallback","cstrDisconnectedCallback","disconnectedCallback","this","call","createProviderConsumer","historyType","location","pathname","query","key","titleSuffix","root","routeViewsUpdated","child","h","renderer","getConfirmation","win","message","callback","confirm","isModifiedEvent","ev","metaKey","altKey","ctrlKey","shiftKey","supportsHistory","ua","navigator","userAgent","indexOf","history","supportsPopStateOnHashChange","nav","supportsGoWithoutReloadUsingHash","isExtraneousPopstateEvent","event","undefined","storageAvailable","type","storage","x","setItem","removeItem","e","DOMException","code","name","length","hasBasename","path","prefix","RegExp","test","stripBasename","substr","stripTrailingSlash","charAt","slice","addLeadingSlash","stripLeadingSlash","createPath","search","hash","isAbsolute","createKey","keyLength","Math","random","toString","spliceOne","list","index","i","k","n","pop","valueEqual","a","b","every","item","aType","aValue","valueOf","bValue","aKeys","keys","bKeys","locationsAreEqual","createLocation","currentLocation","hashIndex","searchIndex","parsePath","decodeURI","URIError","to","hasTrailingSlash","from","fromParts","split","up","toParts","isToAbs","isFromAbs","mustEndAbs","concat","last","part","unshift","result","join","resolvePathname","reduce","params","param","value","decodeURIComponent","replace","warning","args","console","warn","createTransitionManager","prompt","setPrompt","nextPrompt","confirmTransitionTo","action","getUserConfirmation","appendListener","fn","isActive","listener","push","filter","notifyListeners","createScrollHistory","applicationScrollKey","scrollPositions","arrayData","sessionStorage","JSON","stringify","get","capture","scrollX","scrollY","scrollData","getItem","parse","scrollRestoration","PopStateEvent","HashChangeEvent$1","HashChangeEvent","HashPathCoders","hashbang","encodePath","decodePath","noslash","slash","getLocation","HISTORIES","forceNextPop","globalHistory","globalLocation","globalNavigator","canUseHistory","needsHashChangeListener","scrollHistory","forceRefresh","basename","getHistoryState","getDOMLocation","historyState","transitionManager","setState","nextState","scrollPosition","handlePopState","handlePop","handleHashChange","ok","revertPop","fromLocation","toLocation","toIndex","allKeys","fromIndex","delta","go","initialLocation","listenerCount","isBlocked","createHref","href","pushState","prevIndex","nextKeys","replaceState","goBack","goForward","checkDOMListeners","addEventListener","removeEventListener","block","unblock","listen","unlisten","ignorePath","canGoWithoutReload","hashType","getHashPath","substring","pushHashPath","replaceHashPath","encodedPath","prevLocation","allPaths","lastIndexOf","nextPaths","Router","hostRef","registerInstance","options","scrollToId","elm","document","getElementById","scrollIntoView","scrollTo","scrollTopOffset","isServer","getContext","queue","el","ownerDocument","defaultView","scrollToLocation","write","getElement"],"sourceRoot":""}